<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tácticas del Río Revuelto</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@400;700&family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            font-family: 'Roboto Condensed', sans-serif;
            background-color: #1a202c; 
            color: #e2e8f0; 
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            touch-action: manipulation;
            overflow-x: hidden; 
        }
        .game-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.75rem; 
            color: #63b3ed; 
            text-shadow: 2px 2px #2c5282; 
            margin-bottom: 1rem;
        }

        /* Menu & Lobby Styles */
        .menu-screen, .lobby-screen {
            display: flex; /* Will be controlled by JS */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 500px;
            padding: 2rem;
            background-color: #2d3748; /* gray-700 */
            border-radius: 0.75rem;
            box-shadow: 0 8px 25px rgba(0,0,0,0.6);
            text-align: center;
        }
        .menu-screen h2, .lobby-screen h2 {
            font-family: 'Press Start 2P';
            font-size: 1.5rem;
            color: #90cdf4; /* blue-300 */
            margin-bottom: 1.5rem;
        }
        .menu-screen button, .lobby-screen button {
            font-family: 'Press Start 2P';
            font-size: 1rem;
            padding: 0.8rem 1.5rem;
            margin: 0.5rem;
            min-width: 220px; 
        }
        .lobby-screen input[type="text"] {
            font-family: 'Roboto Condensed', sans-serif;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            width: 80%;
            max-width: 250px;
            border-radius: 0.3rem;
            border: 1px solid #4a5568; 
            background-color: #1a202c; 
            color: #e2e8f0; 
            text-align: center;
        }
        .lobby-screen p { margin-bottom: 0.5rem; }
        .user-id-display { font-size: 0.8rem; color: #a0aec0; margin-bottom: 1rem;}
        .game-id-display { font-weight: bold; color: #f6e05e; user-select: all; cursor: pointer; }


        .game-container {
            display: none; 
            flex-direction: column; 
            align-items: center;
            gap: 1.5rem;
            width: 100%;
            max-width: 1200px; 
        }
        .board-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative; 
        }
        #gameBoard {
            display: grid;
            border: 2px solid #4a5568; 
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            position: relative; 
        }
        .tile {
            width: 50px; 
            height: 50px; 
            border: 1px solid #2d3748; 
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s;
            position: relative; 
            overflow: hidden; 
        }
        .tile.grass { background-color: #38a169; } 
        .tile.bridge { background-color: #a0aec0; } 
        .tile.player1-spawn { background-color: #5a67d8; } 
        .tile.player2-spawn { background-color: #e53e3e; } 

        .river-canvas { 
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; 
        }

        .unit { /* This is the div that gets positioned on the grid */
            width: 50px; 
            height: 50px; 
            display: flex; 
            justify-content: center;
            align-items: center;
            user-select: none;
            position: absolute; 
            transition: transform 0.3s ease-out, opacity 0.5s ease-out; 
            z-index: 10;
            box-sizing: border-box; 
        }
        .unit canvas { /* The canvas for drawing the unit, centered within the .unit div */
            display: block; 
            width: 48px; /* UNIT_CANVAS_SIZE */
            height: 48px; /* UNIT_CANVAS_SIZE */
        }

        .unit-p1 { border: 2px solid #fbd38d; } 
        .unit-p2 { border: 2px solid #90cdf4; } 
        
        .selected-unit-tile {
            outline: 3px solid #f6e05e; 
            outline-offset: -3px;
            box-shadow: 0 0 10px #f6e05e;
        }
        .possible-move::after, .possible-attack::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            opacity: 0.7;
            z-index: 1;
        }
        .possible-move::after { background-color: #68d391; } 
        .possible-attack::after { background-color: #fc8181; } 
        
        .unit.pulse-target { 
            animation: pulse-red-border-unit 0.7s infinite alternate;
        }
        @keyframes pulse-red-border-unit {
            from { border-color: #ef4444; box-shadow: 0 0 6px #ef4444, 0 0 3px #ef4444 inset; } 
            to   { border-color: #f87171; box-shadow: 0 0 12px #f87171, 0 0 5px #f87171 inset; } 
        }

        .unit-damaged {
            animation: damage-flash 0.4s ease-out;
        }
        @keyframes damage-flash {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(2.5) saturate(3); } 
        }
        .unit-dying {
            opacity: 0;
        }

        .controls-area {
            background-color: #2d3748; 
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            width: 100%;
            max-width: 300px; 
            text-align: center;
        }
        .info-display { margin-bottom: 0.5rem; } 
        .info-display p { margin: 0.3rem 0; font-size: 1.1rem; }
        .info-display #currentPlayerText.player1 { color: #fbd38d; } 
        .info-display #currentPlayerText.player2 { color: #90cdf4; } 
        .info-display #playerRoleDisplay { font-size: 0.9rem; margin-top: 0.2rem; }
        
        #gameLogDisplay, #unitRosterPanel {
            margin-top: 0.75rem; 
            padding: 0.5rem;
            height: 250px; /* Increased height */
            overflow-y: auto;
            background-color: #1a202c; 
            border-radius: 0.3rem;
            border: 1px solid #4a5568;
            text-align: left;
            font-size: 0.85rem;
        }
        #gameLogDisplay p, #unitRosterPanel p {
            margin-bottom: 0.3rem;
            padding-bottom: 0.3rem;
            border-bottom: 1px dashed #4a5568;
        }
        #gameLogDisplay p:last-child, #unitRosterPanel p:last-child {
            border-bottom: none;
        }
         #gameLogDisplay .log-move { color: #a0aec0; } 
         #gameLogDisplay .log-attack { color: #f56565; } 
         #gameLogDisplay .log-damage { color: #f6e05e; } 
         #gameLogDisplay .log-death { color: #e53e3e; font-weight: bold; } 
         #gameLogDisplay .log-turn { color: #63b3ed; font-style: italic; } 
         #gameLogDisplay .log-system { color: #cbd5e0; font-weight: bold;} 

        #unitRosterPanel .roster-title {
            font-weight: bold;
            color: #90cdf4; 
            text-align: center;
            margin-bottom: 0.5rem;
            padding-bottom: 0.3rem;
            border-bottom: 1px solid #4a5568;
        }
         #unitRosterPanel .unit-entry-p1 { color: #fbd38d; } 
         #unitRosterPanel .unit-entry-p2 { color: #90cdf4; } 


        button {
            font-family: 'Roboto Condensed', sans-serif;
            background-color: #4a5568; 
            color: white;
            padding: 0.6rem 1.2rem;
            border: none;
            border-radius: 0.3rem;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s;
            margin-top: 0.5rem;
        }
        button:hover { background-color: #718096; } 
        button:disabled { background-color: #a0aec0; cursor: not-allowed; } 
        .restart-button, .action-button { 
            background-color: #48bb78; 
        }
        .restart-button:hover, .action-button:hover {
            background-color: #38a169; 
        }
        .secondary-button {
             background-color: #667eea; 
        }
        .secondary-button:hover {
             background-color: #5a67d8; 
        }
        .danger-button {
            background-color: #f56565; 
        }
        .danger-button:hover {
            background-color: #e53e3e; 
        }


        #selectedUnitInfo {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid #4a5568;
        }
        #selectedUnitInfo p { margin: 0.2rem 0; }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.8); 
        }
        .modal-content {
            background-color: #2d3748; 
            color: #e2e8f0; 
            margin: 10% auto; 
            padding: 30px; 
            border: 2px solid #63b3ed; 
            border-radius: 0.75rem; 
            width: 90%;
            max-width: 550px; 
            text-align: center;
            box-shadow: 0 8px 25px rgba(0,0,0,0.6);
        }
        .modal-content h2 { 
            font-family: 'Press Start 2P'; 
            font-size: 2rem; 
            margin-bottom: 1.5rem; 
            line-height: 1.3;
        }
        .modal-content .winner-player1 { color: #fbd38d; } 
        .modal-content .winner-player2 { color: #90cdf4; } 


        @media (min-width: 768px) { 
            .game-container {
                flex-direction: row;
                align-items: flex-start;
            }
            .controls-area {
                max-width: 320px; 
            }
            .game-title {
                font-size: 2.25rem;
            }
        }
        @media (max-width: 400px) {
             .tile { width: 40px; height: 40px; }
             .unit { width: 40px; height: 40px; } 
             .unit canvas { width: 38px; height: 38px; } 
             .game-title { font-size: 1.5rem; }
             .modal-content h2 { font-size: 1.5rem; }
        }

    </style>
</head>
<body>
    <h1 class="game-title">Tácticas del Río Revuelto</h1>

    <div id="authLoadingScreen" class="menu-screen">
        <h2>Conectando...</h2>
        <p class="user-id-display">Autenticando con Firebase...</p>
    </div>
    
    <div id="mainMenuScreen" class="menu-screen" style="display: none;">
        <h2>Modo de Juego</h2>
        <button id="localMultiplayerBtn" class="action-button">Multijugador Local</button>
        <button id="vsAIBtn" class="action-button">VS IA</button>
        <button id="onlineMultiplayerBtn" class="action-button">Multijugador Online</button>
    </div>

    <div id="difficultyScreen" class="menu-screen" style="display: none;">
        <h2>Dificultad IA</h2>
        <button id="aiEasyBtn" class="bg-teal-500 hover:bg-teal-600" data-difficulty="easy">Fácil</button>
        <button id="aiMediumBtn" class="bg-orange-500 hover:bg-orange-600" data-difficulty="medium">Medio</button>
        <button id="aiHardBtn" class="bg-red-500 hover:bg-red-600" data-difficulty="hard">Difícil</button>
        <button id="backToMainMenuBtn_Diff" class="bg-gray-500 hover:bg-gray-600 mt-4">Volver al Menú</button>
    </div>
    
    <div id="onlineLobbyScreen" class="lobby-screen" style="display: none;">
        <h2>Multijugador Online</h2>
        <p class="user-id-display">Tu ID de Jugador: <span id="playerUserIdDisplay_Lobby"></span></p>
        <button id="createGameBtn_Lobby" class="action-button">Crear Nueva Partida</button>
        <div class="mt-4">
            <input type="text" id="joinGameIdInput_Lobby" placeholder="ID de Partida para Unirse">
            <button id="joinGameBtn_Lobby" class="secondary-button">Unirse a Partida</button>
        </div>
        <button id="backToMainMenuBtn_Lobby" class="bg-gray-500 hover:bg-gray-600 mt-4">Volver al Menú</button>
    </div>


    <div id="waitingRoomScreen" class="lobby-screen" style="display: none;">
        <h2>Sala de Espera</h2>
        <p>ID de Partida: <strong id="waitingGameIdDisplay" class="game-id-display"></strong> (comparte esto)</p>
        <p id="waitingStatusText">Esperando al oponente...</p>
        <div id="playerList" class="mt-2 mb-2"></div>
        <button id="leaveWaitingRoomBtn" class="danger-button mt-4">Salir de la Sala</button>
    </div>


    <div id="gameContainer" class="game-container">
        <div class="board-area">
            <div id="gameBoard"></div>
            <div id="unitLayer" style="position: absolute; top: 0; left: 0; pointer-events: none;"></div>
        </div>

        <div class="controls-area">
            <div class="info-display">
                <p>Turno de: <span id="currentPlayerText">Jugador X</span></p>
                <p id="playerRoleDisplay">Eres: Jugador X</p>
                <p id="gameModeInfoDisplay" class="text-sm text-gray-400">Modo: ---</p>
                <p id="gameIdInfoDisplay" class="text-sm text-gray-400" style="display:none;">Partida ID: ---</p>
                 <p id="aiTurnIndicator" class="text-yellow-400 font-bold" style="display: none;">Turno de la IA...</p>
            </div>
            
            <div id="selectedUnitInfo">
                <p class="font-bold text-lg">Unidad Seleccionada:</p>
                <p id="unitName">Ninguna</p>
                <p>PV: <span id="unitHealth">--</span></p>
                <p>Ataque: <span id="unitAttack">--</span></p>
                <p>Mov: <span id="unitMovement">--</span></p>
            </div>

            <div id="unitRosterPanel">
                <p class="roster-title">Unidades del Jugador Actual</p>
            </div>

            <div id="gameLogDisplay">
                <p class="text-gray-500 text-center">Registro de Partida...</p>
            </div>
            <button id="generalLeaveGameBtn" class="w-full danger-button">Salir / Volver al Menú</button>
        </div>
    </div>

    <div id="gameOverModal" class="modal">
        <div class="modal-content">
            <h2 id="gameOverMessage">¡Jugador X Gana!</h2>
            <button id="modalLeaveGameBtn" class="danger-button">Volver al Menú</button>
        </div>
    </div>
     <div id="notificationModal" class="modal" style="z-index: 1001;">
        <div class="modal-content" style="max-width: 400px; background-color: #4A5568; color:white;">
            <h3 id="notificationTitle" class="text-xl font-bold mb-3 text-yellow-300">Notificación</h3>
            <p id="notificationMessageText" class="text-md"></p>
            <button id="notificationOkBtn" class="mt-4 bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg">OK</button>
        </div>
    </div>


    <script type="module">
        // --- Firebase Configuration (User Provided) ---
        const firebaseConfig = {
          apiKey: "AIzaSyBDU96-kttzuUyFyhG5CZPnEQspYon-rnw",
          authDomain: "advancechess-168a1.firebaseapp.com",
          projectId: "advancechess-168a1",
          storageBucket: "advancechess-168a1.firebasestorage.app", // Using user-provided value
          messagingSenderId: "772409857798",
          appId: "1:772409857798:web:f3c8618b7b9ad98d9fb087",
          measurementId: "G-BGMXVE91TJ" 
        };

        // Firebase SDK imports
        let firebaseApp, firebaseAuth, firestoreDB;
        let doc, setDoc, getDoc, onSnapshot, updateDoc, serverTimestamp, runTransaction, deleteDoc, signInAnonymously, onAuthStateChanged, signInWithCustomToken;

        async function initializeFirebase() {
            if (firebaseConfig.apiKey) {
                try {
                    const fb = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js");
                    const authFb = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js");
                    const firestoreFb = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js");

                    firebaseApp = fb.initializeApp(firebaseConfig);
                    firebaseAuth = authFb.getAuth(firebaseApp);
                    firestoreDB = firestoreFb.getFirestore(firebaseApp);
                    // firestoreFb.setLogLevel('debug'); // Uncomment for Firestore debugging
                    
                    doc = firestoreFb.doc;
                    setDoc = firestoreFb.setDoc;
                    getDoc = firestoreFb.getDoc;
                    onSnapshot = firestoreFb.onSnapshot;
                    updateDoc = firestoreFb.updateDoc;
                    serverTimestamp = firestoreFb.serverTimestamp;
                    runTransaction = firestoreFb.runTransaction;
                    deleteDoc = firestoreFb.deleteDoc;
                    signInAnonymously = authFb.signInAnonymously;
                    onAuthStateChanged = authFb.onAuthStateChanged;
                    signInWithCustomToken = authFb.signInWithCustomToken;

                    console.log("Firebase initialized successfully for deployment.");
                    return true; // Indicate success
                } catch (error) {
                    console.error("Error initializing Firebase for deployment:", error);
                    document.getElementById('authLoadingScreen').innerHTML = '<h2>Error Crítico</h2><p>No se pudo inicializar Firebase. Revisa la consola.</p>';
                    return false; // Indicate failure
                }
            } else {
                console.error("Firebase configuration object is missing API key.");
                document.getElementById('authLoadingScreen').innerHTML = '<h2>Error de Configuración</h2><p>Falta la configuración de Firebase.</p>';
                return false; // Indicate failure
            }
        }
        
        // Game Constants
        const BOARD_ROWS = 12; 
        const BOARD_COLS = 9;  
        const TILE_SIZE = 50; 
        const UNIT_DIV_SIZE = TILE_SIZE;
        const UNIT_CANVAS_SIZE = TILE_SIZE - 2; 
        const UNIT_CANVAS_OFFSET = (UNIT_DIV_SIZE - UNIT_CANVAS_SIZE) / 2; 
        const PIXEL_GRID_SIZE = 16; 

        const RIVER_START_ROW = 5;
        const RIVER_END_ROW = 6;
        const BRIDGE_COL_1 = 2;
        const BRIDGE_COL_2 = 6;

        const UNIT_TYPES = { 
            BASE: { name: 'Base', hp: 50, attack: 0, movement: 0, range: 0, class: 'base', isMobile: false, drawFunc: 'drawBase' },
            GUERRERO: { name: 'Guerrero', hp: 20, attack: 8, movement: 2, range: 1, class: 'guerrero', isMobile: true, drawFunc: 'drawGuerrero' },
            ARQUERO: { name: 'Arquero', hp: 15, attack: 6, movement: 2, range: 3, class: 'arquero', isMobile: true, drawFunc: 'drawArquero' },
            GIGANTE: { name: 'Gigante', hp: 35, attack: 10, movement: 1, range: 1, class: 'gigante', isMobile: true, drawFunc: 'drawGigante' }
        };

        let gameState = {
            board: [], units: {}, riverCanvases: [], riverAnimationTime: 0,
            currentFirebaseGameData: null, localPlayerId: null, localPlayerRole: null, 
            localPlayerNumber: null, currentGameId: null, selectedUnit: null, 
            highlightedMoves: [], gameActive: false, isAnimating: false, gameLog: [],
            gameMode: null, aiDifficulty: null, aiPlayerNumber: 2, 
            unsubscribeGameListener: null 
        };

        function renderGameLog() {
            if (!gameLogDisplay) return;
            gameLogDisplay.innerHTML = '';
            if (gameState.gameLog.length === 0) {
                const p = document.createElement('p');
                p.textContent = "No hay eventos en el registro.";
                p.classList.add('text-gray-500', 'text-center');
                gameLogDisplay.appendChild(p);
                return;
            }
            gameState.gameLog.forEach(entry => {
                const p = document.createElement('p');
                const date = new Date(entry.timestamp);
                const timeString = `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}`;
                p.textContent = `[${timeString}] ${entry.text}`;
                if (entry.type) p.classList.add(`log-${entry.type}`);
                gameLogDisplay.appendChild(p);
            });
            gameLogDisplay.scrollTop = 0; // Show latest entries first
        }

        function addLogEntry(message, type) {
            if (!gameState.gameLog) {
                gameState.gameLog = [];
            }
            const newEntry = {
                text: message,
                type: type,
                timestamp: new Date().toISOString()
            };
            gameState.gameLog.unshift(newEntry); // Add to the beginning
            if (gameState.gameLog.length > 50) { // Keep the log size to 50
                gameState.gameLog.pop();
            }
            // It's important to call renderGameLog() if it's not called immediately
            // after every action that might use addLogEntry.
            // For now, let's assume renderGameLog is called separately or after a batch of updates.
            // If direct rendering is needed, uncomment the line below.
            renderGameLog();
        }

        let moveSound, attackSound, damageSound, deathSound, turnSound;

        function initializeSounds() {
            if (typeof Tone !== 'undefined') {
                moveSound = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.2 } }).toDestination();
                moveSound.volume.value = -15;
                attackSound = new Tone.NoiseSynth({ noise: { type: "white" }, envelope: { attack: 0.005, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination();
                attackSound.volume.value = -10;
                damageSound = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 5, envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.1 } }).toDestination();
                damageSound.volume.value = -8;
                deathSound = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.5 } }).toDestination();
                deathSound.volume.value = -12;
                turnSound = new Tone.Synth({ oscillator: {type: "square"}, envelope: {attack: 0.01, decay: 0.08, sustain: 0.01, release: 0.1} }).toDestination();
                turnSound.volume.value = -18;
                 console.log("Sonidos inicializados con Tone.js");
            } else { console.warn("Tone.js no está cargado."); }
        }
        function playSound(type, note = null) {
            if (typeof Tone === 'undefined' || !Tone.context || Tone.context.state !== 'running') {
                if (Tone && Tone.context && Tone.context.state !== 'running') {
                    Tone.start().then(() => {}).catch(e => {});
                } return; 
            }
            switch(type) {
                case 'move': if(moveSound) moveSound.triggerAttackRelease(note || "C4", "8n"); break;
                case 'attack': if(attackSound) attackSound.triggerAttackRelease("8n"); break;
                case 'damage': if(damageSound) damageSound.triggerAttackRelease(note || "C3", "8n", Tone.now(), 0.8); break;
                case 'death': if(deathSound) deathSound.triggerAttackRelease(note || "C2", "2n"); break;
                case 'turn': if(turnSound) turnSound.triggerAttackRelease(note || "E5", "16n"); break;
            }
        }
        
        const authLoadingScreen = document.getElementById('authLoadingScreen');
        const mainMenuScreen = document.getElementById('mainMenuScreen');
        const difficultyScreen = document.getElementById('difficultyScreen');
        const onlineLobbyScreen = document.getElementById('onlineLobbyScreen');
        const gameContainer = document.getElementById('gameContainer');
        const localMultiplayerBtn = document.getElementById('localMultiplayerBtn');
        const vsAIBtn = document.getElementById('vsAIBtn');
        const onlineMultiplayerBtn = document.getElementById('onlineMultiplayerBtn');
        const aiEasyBtn = document.getElementById('aiEasyBtn');
        const aiMediumBtn = document.getElementById('aiMediumBtn');
        const aiHardBtn = document.getElementById('aiHardBtn');
        const backToMainMenuBtn_Diff = document.getElementById('backToMainMenuBtn_Diff');
        const playerUserIdDisplay_Lobby = document.getElementById('playerUserIdDisplay_Lobby');
        const createGameBtn_Lobby = document.getElementById('createGameBtn_Lobby');
        const joinGameIdInput_Lobby = document.getElementById('joinGameIdInput_Lobby');
        const joinGameBtn_Lobby = document.getElementById('joinGameBtn_Lobby');
        const backToMainMenuBtn_Lobby = document.getElementById('backToMainMenuBtn_Lobby');
        const waitingRoomScreen = document.getElementById('waitingRoomScreen');
        const waitingGameIdDisplay = document.getElementById('waitingGameIdDisplay');
        const waitingStatusText = document.getElementById('waitingStatusText');
        const playerListDiv = document.getElementById('playerList');
        const leaveWaitingRoomBtn = document.getElementById('leaveWaitingRoomBtn');
        const gameBoardElement = document.getElementById('gameBoard');
        const unitLayerElement = document.getElementById('unitLayer'); 
        const currentPlayerText = document.getElementById('currentPlayerText');
        const playerRoleDisplay = document.getElementById('playerRoleDisplay');
        const gameModeInfoDisplay = document.getElementById('gameModeInfoDisplay');
        const gameIdInfoDisplay = document.getElementById('gameIdInfoDisplay');
        const aiTurnIndicator = document.getElementById('aiTurnIndicator');
        const unitNameText = document.getElementById('unitName');
        const unitHealthText = document.getElementById('unitHealth');
        const unitAttackText = document.getElementById('unitAttack');
        const unitMovementText = document.getElementById('unitMovement');
        const gameLogDisplay = document.getElementById('gameLogDisplay');
        const unitRosterPanel = document.getElementById('unitRosterPanel');
        const generalLeaveGameBtn = document.getElementById('generalLeaveGameBtn');
        const gameOverModal = document.getElementById('gameOverModal');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const modalLeaveGameBtn = document.getElementById('modalLeaveGameBtn');
        const notificationModal = document.getElementById('notificationModal');
        const notificationTitle = document.getElementById('notificationTitle');
        const notificationMessageText = document.getElementById('notificationMessageText');
        const notificationOkBtn = document.getElementById('notificationOkBtn');

        function showNotification(title, message) {
            notificationTitle.textContent = title;
            notificationMessageText.textContent = message;
            notificationModal.style.display = "flex"; 
        }
        notificationOkBtn.addEventListener('click', () => notificationModal.style.display = "none");

        function createUnitData(type, player, id) { 
            const unitTypeDetails = UNIT_TYPES[type]; 
            return { 
                id: `p${player}-${type.toLowerCase()}-${id}`, type: type, player: player,
                hp: unitTypeDetails.hp, maxHp: unitTypeDetails.hp, attack: unitTypeDetails.attack,
                movement: unitTypeDetails.movement, range: unitTypeDetails.range,
                class: unitTypeDetails.class, isMobile: unitTypeDetails.isMobile,
                drawFuncKey: unitTypeDetails.drawFunc, row: -1, col: -1  
            };
        }
        
        function drawPixel(ctx, x, y, color, pixelSize, artOffsetX = 0, artOffsetY = 0) {
            ctx.fillStyle = color;
            ctx.fillRect(artOffsetX + x * pixelSize, artOffsetY + y * pixelSize, pixelSize, pixelSize);
        }
        const unitDrawFunctions = { 
            drawBase: (ctx, canvasSize, isPlayer1) => {
                const pSize = Math.floor(canvasSize / PIXEL_GRID_SIZE); 
                const artActualWidth = PIXEL_GRID_SIZE * pSize; const artActualHeight = PIXEL_GRID_SIZE * pSize;
                const artOffsetX = (canvasSize - artActualWidth) / 2; const artOffsetY = (canvasSize - artActualHeight) / 2;
                const wall = isPlayer1 ? '#8B572A' : '#6C7A89'; const roof = isPlayer1 ? '#CD853F' : '#95A5A6'; 
                const detail = isPlayer1 ? '#5D4037' : '#34495E'; const shadow = '#4A3B31';
                ctx.clearRect(0,0, canvasSize, canvasSize);
                for (let y = 4; y < 14; y++) for (let x = 2; x < 14; x++) drawPixel(ctx, x, y, wall, pSize, artOffsetX, artOffsetY);
                for (let x = 3; x < 13; x++) drawPixel(ctx, x, 3, roof, pSize, artOffsetX, artOffsetY); 
                for (let i = 0; i < 5; i++) { drawPixel(ctx, 2 + i*2, 2, wall, pSize, artOffsetX, artOffsetY); if (i < 4) drawPixel(ctx, 3 + i*2, 2, detail, pSize, artOffsetX, artOffsetY);}
                drawPixel(ctx, 12, 2, wall, pSize, artOffsetX, artOffsetY);
                for (let y = 10; y < 13; y++) for (let x = 6; x < 10; x++) drawPixel(ctx, x, y, detail, pSize, artOffsetX, artOffsetY); 
                drawPixel(ctx, 4, 5, shadow, pSize, artOffsetX, artOffsetY); drawPixel(ctx, 11, 5, shadow, pSize, artOffsetX, artOffsetY); 
                drawPixel(ctx, 4, 8, shadow, pSize, artOffsetX, artOffsetY); drawPixel(ctx, 11, 8, shadow, pSize, artOffsetX, artOffsetY);
            },
            drawGuerrero: (ctx, canvasSize, isPlayer1) => {
                const pSize = Math.floor(canvasSize / PIXEL_GRID_SIZE);
                const artActualWidth = PIXEL_GRID_SIZE * pSize; const artActualHeight = PIXEL_GRID_SIZE * pSize;
                const artOffsetX = (canvasSize - artActualWidth) / 2; const artOffsetY = (canvasSize - artActualHeight) / 2;
                const skin = '#FFDBAC'; const skinShadow = '#E0AC69'; const hair = isPlayer1 ? '#7A4E3D' : '#555555'; 
                const armorMain = isPlayer1 ? '#B22222' : '#4169E1'; const armorAccent = isPlayer1 ? '#DC143C' : '#6495ED'; 
                const swordBlade = '#E0E0E0'; const swordGuard = '#A0A0A0'; const swordHilt = '#6F4E37'; 
                ctx.clearRect(0,0, canvasSize, canvasSize);
                for(let y=2; y<6; y++) for(let x=6; x<10; x++) drawPixel(ctx, x, y, skin, pSize, artOffsetX, artOffsetY);
                for(let x=6; x<10; x++) drawPixel(ctx, x,1,hair,pSize, artOffsetX, artOffsetY); 
                drawPixel(ctx, 6,2,hair,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 9,2,hair,pSize, artOffsetX, artOffsetY);
                drawPixel(ctx, 7,4,skinShadow,pSize, artOffsetX, artOffsetY); 
                for(let y=6; y<12; y++) for(let x=5; x<11; x++) drawPixel(ctx, x, y, armorMain, pSize, artOffsetX, artOffsetY);
                drawPixel(ctx, 7,6,armorAccent,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 8,6,armorAccent,pSize, artOffsetX, artOffsetY); 
                drawPixel(ctx, 5,7,armorAccent,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 10,7,armorAccent,pSize, artOffsetX, artOffsetY); 
                for(let y=12; y<15; y++) { drawPixel(ctx, 5,y,armorMain,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 6,y,armorMain,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 9,y,armorMain,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 10,y,armorMain,pSize, artOffsetX, artOffsetY); }
                drawPixel(ctx, 5,15,armorAccent,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 6,15,armorAccent,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 9,15,armorAccent,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 10,15,armorAccent,pSize, artOffsetX, artOffsetY);
                drawPixel(ctx, 12, 11, swordHilt, pSize, artOffsetX, artOffsetY); drawPixel(ctx, 12, 10, swordHilt, pSize, artOffsetX, artOffsetY);
                drawPixel(ctx, 11, 9, swordGuard, pSize, artOffsetX, artOffsetY); drawPixel(ctx, 13, 9, swordGuard, pSize, artOffsetX, artOffsetY);
                for(let i=0; i<7; i++) drawPixel(ctx, 12, 8-i, swordBlade, pSize, artOffsetX, artOffsetY); 
                drawPixel(ctx, 12, 1, '#FFFFFF', pSize, artOffsetX, artOffsetY); 
                const shieldMain = isPlayer1 ? '#8B0000' : '#00008B'; const shieldAccent = isPlayer1 ? '#CD5C5C' : '#ADD8E6'; 
                for(let y=6; y<11; y++) drawPixel(ctx, 2,y,shieldMain,pSize, artOffsetX, artOffsetY);
                for(let y=7; y<10; y++) drawPixel(ctx, 3,y,shieldMain,pSize, artOffsetX, artOffsetY);
                drawPixel(ctx, 1,7,shieldMain,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 1,8,shieldMain,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 1,9,shieldMain,pSize, artOffsetX, artOffsetY);
                drawPixel(ctx, 2,8,shieldAccent,pSize, artOffsetX, artOffsetY); 
            },
             drawArquero: (ctx, canvasSize, isPlayer1) => {
                const pSize = Math.floor(canvasSize / PIXEL_GRID_SIZE);
                const artActualWidth = PIXEL_GRID_SIZE * pSize; const artActualHeight = PIXEL_GRID_SIZE * pSize;
                const artOffsetX = (canvasSize - artActualWidth) / 2; const artOffsetY = (canvasSize - artActualHeight) / 2;
                const skin = '#FFDBAC'; const skinShadow = '#E0AC69'; const hair = isPlayer1 ? '#9ACD32' : '#FFD700'; 
                const tunicMain = isPlayer1 ? '#006400' : '#483D8B'; const tunicAccent = isPlayer1 ? '#2E8B57' : '#6A5ACD'; 
                const bowWood = '#8B4513'; const arrowFletching = '#FFF8DC'; 
                ctx.clearRect(0,0, canvasSize, canvasSize);
                for(let y=2; y<6; y++) for(let x=6; x<10; x++) drawPixel(ctx, x, y, skin, pSize, artOffsetX, artOffsetY);
                for(let x=6; x<10; x++) drawPixel(ctx, x,1,hair,pSize, artOffsetX, artOffsetY);
                drawPixel(ctx, 6,2,hair,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 9,2,hair,pSize, artOffsetX, artOffsetY);
                drawPixel(ctx, 7,4,skinShadow,pSize, artOffsetX, artOffsetY);
                for(let y=6; y<12; y++) for(let x=5; x<11; x++) drawPixel(ctx, x, y, tunicMain, pSize, artOffsetX, artOffsetY);
                drawPixel(ctx, 7,6,tunicAccent,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 8,6,tunicAccent,pSize, artOffsetX, artOffsetY); 
                for(let y=12; y<15; y++) { drawPixel(ctx, 5,y,tunicMain,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 6,y,tunicMain,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 9,y,tunicMain,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 10,y,tunicMain,pSize, artOffsetX, artOffsetY); }
                drawPixel(ctx, 5,15,tunicAccent,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 6,15,tunicAccent,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 9,15,tunicAccent,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 10,15,tunicAccent,pSize, artOffsetX, artOffsetY);
                drawPixel(ctx, 3, 1, bowWood, pSize, artOffsetX, artOffsetY);
                for(let i=0; i<12; i++) drawPixel(ctx, 4, 2+i, bowWood, pSize, artOffsetX, artOffsetY);
                drawPixel(ctx, 3, 14, bowWood, pSize, artOffsetX, artOffsetY);
                ctx.strokeStyle = '#C0C0C0'; ctx.lineWidth = pSize/2; ctx.beginPath();
                ctx.moveTo(artOffsetX + 3.5*pSize, artOffsetY + 1.5*pSize); ctx.lineTo(artOffsetX + 3.5*pSize, artOffsetY + 14.5*pSize);
                ctx.stroke();
                for(let i=0; i<5; i++) drawPixel(ctx, 5+i, 7, '#A0522D', pSize, artOffsetX, artOffsetY); 
                drawPixel(ctx, 10, 7, '#B0B0B0', pSize, artOffsetX, artOffsetY); 
                drawPixel(ctx, 4,7,arrowFletching,pSize, artOffsetX, artOffsetY);
            },
            drawGigante: (ctx, canvasSize, isPlayer1) => {
                const pSize = Math.floor(canvasSize / PIXEL_GRID_SIZE);
                const artActualWidth = PIXEL_GRID_SIZE * pSize; const artActualHeight = PIXEL_GRID_SIZE * pSize;
                const artOffsetX = (canvasSize - artActualWidth) / 2; const artOffsetY = (canvasSize - artActualHeight) / 2;
                const skin = isPlayer1 ? '#DEB887' : '#A9A9A9'; const skinShadow = isPlayer1 ? '#CD853F' : '#696969'; 
                const loincloth = isPlayer1 ? '#8B4513' : '#556B2F'; const clubWood = '#A0522D'; const clubStone = '#708090'; 
                ctx.clearRect(0,0, canvasSize, canvasSize);
                for(let y=1; y<5; y++) for(let x=5; x<11; x++) drawPixel(ctx, x,y,skin,pSize, artOffsetX, artOffsetY);
                drawPixel(ctx, 6,2,skinShadow,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 9,2,skinShadow,pSize, artOffsetX, artOffsetY); 
                for(let y=5; y<12; y++) for(let x=1; x<15; x++) drawPixel(ctx, x,y,skin,pSize, artOffsetX, artOffsetY);
                for(let y=5; y<12; y++) { drawPixel(ctx,1,y,skinShadow,pSize, artOffsetX, artOffsetY); drawPixel(ctx,14,y,skinShadow,pSize, artOffsetX, artOffsetY); }
                for(let x=2; x<14; x++) drawPixel(ctx,x,11,skinShadow,pSize, artOffsetX, artOffsetY); 
                for(let y=12; y<14; y++) for(let x=4; x<12; x++) drawPixel(ctx, x,y,loincloth,pSize, artOffsetX, artOffsetY);
                for(let y=14; y<16; y++) { for(let x=2; x<7; x++) drawPixel(ctx,x,y,skin,pSize, artOffsetX, artOffsetY); for(let x=9; x<14; x++) drawPixel(ctx,x,y,skin,pSize, artOffsetX, artOffsetY); }
                for(let x=2; x<7; x++) drawPixel(ctx,x,15,skinShadow,pSize, artOffsetX, artOffsetY);
                for(let x=9; x<14; x++) drawPixel(ctx,x,15,skinShadow,pSize, artOffsetX, artOffsetY);
                for(let y=3; y<12; y++) drawPixel(ctx, 13,y,clubWood,pSize, artOffsetX, artOffsetY); 
                drawPixel(ctx, 14,2,clubStone,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 15,2,clubStone,pSize, artOffsetX, artOffsetY);
                drawPixel(ctx, 13,3,clubStone,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 14,3,clubStone,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 15,3,clubStone,pSize, artOffsetX, artOffsetY);
                drawPixel(ctx, 12,4,clubStone,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 13,4,clubStone,pSize, artOffsetX, artOffsetY); drawPixel(ctx, 14,4,clubStone,pSize, artOffsetX, artOffsetY);
            }
        };
        
        function drawRiverTile(ctx, width, height, time) {
            const waveHeight = 4; const waveLength = 20; const speed = 0.05; const numWaves = 3;
            const baseColor = '#3B82F6'; const highlightColor = '#60A5FA'; const shadowColor = '#2563EB'; 
            ctx.fillStyle = baseColor; ctx.fillRect(0, 0, width, height);
            for (let i = 0; i < numWaves; i++) {
                ctx.beginPath();
                const yOffset = (height / numWaves) * i + (height / (numWaves * 2)); 
                const timeOffset = i * 0.5; 
                for (let x = 0; x <= width; x++) {
                    const y = yOffset + Math.sin(x / waveLength + time * speed + timeOffset) * waveHeight;
                    if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.strokeStyle = highlightColor; ctx.lineWidth = 3; ctx.stroke();
                ctx.beginPath();
                 for (let x = 0; x <= width; x++) {
                    const y = yOffset + Math.sin(x / waveLength + time * speed + timeOffset) * waveHeight + 2; 
                    if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.strokeStyle = shadowColor; ctx.lineWidth = 1; ctx.stroke();
            }
        }
        
        function animateRiver() {
            gameState.riverAnimationTime += 1;
            gameState.riverCanvases.forEach(rCtx => {
                if (rCtx.canvas) { 
                    drawRiverTile(rCtx, rCtx.canvas.width, rCtx.canvas.height, gameState.riverAnimationTime);
                }
            });
            requestAnimationFrame(animateRiver);
        }

        // --- Game State & Logic Functions (Many are similar to online, adapted for local/AI) ---
        function initializeLocalBoardAndUnits() { // For Local Multiplayer and VS AI
            gameState.board = Array(BOARD_ROWS).fill(null).map(() => Array(BOARD_COLS).fill(null));
            gameState.units = {}; 
            gameState.riverCanvases = []; 
            unitLayerElement.innerHTML = ''; 
            unitLayerElement.style.width = `${BOARD_COLS * TILE_SIZE}px`; 
            unitLayerElement.style.height = `${BOARD_ROWS * TILE_SIZE}px`;

            gameBoardElement.innerHTML = ''; 
            gameBoardElement.style.gridTemplateColumns = `repeat(${BOARD_COLS}, ${TILE_SIZE}px)`;
            gameBoardElement.style.gridTemplateRows = `repeat(${BOARD_ROWS}, ${TILE_SIZE}px)`;

            for (let r = 0; r < BOARD_ROWS; r++) {
                for (let c = 0; c < BOARD_COLS; c++) {
                    const tile = document.createElement('div');
                    const tileType = getTileType(r, c);
                    tile.classList.add('tile', tileType);
                    tile.dataset.row = r;
                    tile.dataset.col = c;
                    if (tileType === 'river') {
                        const canvas = document.createElement('canvas');
                        canvas.width = TILE_SIZE; canvas.height = TILE_SIZE;
                        canvas.classList.add('river-canvas');
                        tile.appendChild(canvas);
                        gameState.riverCanvases.push(canvas.getContext('2d'));
                    }
                    tile.addEventListener('click', () => onTileClick(r, c));
                    gameBoardElement.appendChild(tile);
                }
            }
            
            const placeUnit = (unitData, r, c) => {
                unitData.row = r; unitData.col = c;
                gameState.board[r][c] = unitData; 
                createUnitElement(unitData); 
            };

            placeUnit(createUnitData('BASE', 1, 0), BOARD_ROWS - 1, Math.floor(BOARD_COLS / 2));
            placeUnit(createUnitData('GUERRERO', 1, 1), BOARD_ROWS - 2, Math.floor(BOARD_COLS / 2) - 1);
            placeUnit(createUnitData('ARQUERO', 1, 2), BOARD_ROWS - 2, Math.floor(BOARD_COLS / 2) + 1);
            placeUnit(createUnitData('GIGANTE', 1, 3), BOARD_ROWS - 3, Math.floor(BOARD_COLS / 2));

            placeUnit(createUnitData('BASE', 2, 0), 0, Math.floor(BOARD_COLS / 2));
            placeUnit(createUnitData('GUERRERO', 2, 1), 1, Math.floor(BOARD_COLS / 2) - 1);
            placeUnit(createUnitData('ARQUERO', 2, 2), 1, Math.floor(BOARD_COLS / 2) + 1);
            placeUnit(createUnitData('GIGANTE', 2, 3), 2, Math.floor(BOARD_COLS / 2));

            gameState.currentPlayer = 1; 
            gameState.localPlayerNumber = 1; 
            gameState.selectedUnit = null;
            gameState.highlightedMoves = [];
            gameState.gameActive = true;
            gameState.isAnimating = false;
            gameState.gameLog = [];
            addLogEntry("Nueva partida " + gameState.gameMode + " iniciada.", "system");
            // renderGameLog(); // Now called by addLogEntry
            renderUnitRosterLocal(); 
             if (gameState.gameMode === 'vsAI' && gameState.currentPlayer === gameState.aiPlayerNumber) {
                aiTurnIndicator.style.display = 'block';
                setTimeout(aiTakeTurn, 1000); 
            } else {
                aiTurnIndicator.style.display = 'none';
            }
        }
        
        function createUnitElement(unitData) { 
            const unitElement = document.createElement('div');
            unitElement.id = unitData.id;
            unitElement.classList.add('unit', unitData.player === 1 ? 'unit-p1' : 'unit-p2');

            const canvas = document.createElement('canvas');
            canvas.width = UNIT_CANVAS_SIZE; 
            canvas.height = UNIT_CANVAS_SIZE;
            // Canvas is centered by flex on .unit div, no need for absolute positioning here
            unitElement.appendChild(canvas); 

            const ctx = canvas.getContext('2d');
            const drawFunction = unitDrawFunctions[unitData.drawFuncKey];
            if (drawFunction) {
                drawFunction(ctx, UNIT_CANVAS_SIZE, unitData.player === 1);
            } else {
                ctx.fillStyle = 'magenta'; 
                ctx.fillRect(0,0, UNIT_CANVAS_SIZE, UNIT_CANVAS_SIZE);
            }
            
            unitElement.style.transform = `translate(${unitData.col * TILE_SIZE}px, ${unitData.row * TILE_SIZE}px)`;
            unitElement.__unitData = unitData; 
            unitLayerElement.appendChild(unitElement);
            gameState.units[unitData.id] = unitElement; 
            return unitElement;
        }

        function getTileType(row, col) {
            if (row >= RIVER_START_ROW && row <= RIVER_END_ROW) {
                if (col === BRIDGE_COL_1 || col === BRIDGE_COL_2) return 'bridge';
                return 'river';
            }
            if (row >= BOARD_ROWS - 2) return 'player1-spawn'; 
            if (row <= 1) return 'player2-spawn'; 
            return 'grass';
        }
        
        function renderUnitRosterLocal() { 
            unitRosterPanel.innerHTML = ''; 
            const title = document.createElement('p');
            title.classList.add('roster-title');
            title.textContent = `Unidades del Jugador ${gameState.currentPlayer}`;
            unitRosterPanel.appendChild(title);

            let unitsFound = false;
            for (const unitId in gameState.units) { 
                const unitElement = gameState.units[unitId];
                const unitData = unitElement.__unitData; 

                if (unitData && unitData.player === gameState.currentPlayer) {
                    unitsFound = true;
                    const p = document.createElement('p');
                    p.textContent = `${UNIT_TYPES[unitData.type].name}: ${unitData.hp}/${unitData.maxHp} PV`;
                    p.classList.add(unitData.player === 1 ? 'unit-entry-p1' : 'unit-entry-p2');
                    unitRosterPanel.appendChild(p);
                }
            }
            if (!unitsFound) {
                 const p = document.createElement('p');
                 p.textContent = "Ninguna unidad activa.";
                 p.classList.add("text-gray-500", "text-center");
                 unitRosterPanel.appendChild(p);
            }
             unitRosterPanel.scrollTop = 0;
        }


        function renderHighlightsAndInfo() { 
            document.querySelectorAll('.tile.selected-unit-tile, .tile.possible-move, .tile.possible-attack')
                .forEach(el => el.classList.remove('selected-unit-tile', 'possible-move', 'possible-attack'));
            document.querySelectorAll('.unit.pulse-target').forEach(el => el.classList.remove('pulse-target'));

            if (gameState.selectedUnit) {
                const unitData = gameState.selectedUnit.data;
                const tileEl = gameBoardElement.querySelector(`.tile[data-row='${unitData.row}'][data-col='${unitData.col}']`);
                if (tileEl) tileEl.classList.add('selected-unit-tile');
            }

            gameState.highlightedMoves.forEach(move => {
                const tileEl = gameBoardElement.querySelector(`.tile[data-row='${move.row}'][data-col='${move.col}']`);
                if (tileEl) {
                    tileEl.classList.add(move.type === 'move' ? 'possible-move' : 'possible-attack');
                    if (move.type === 'attack') {
                        const targetUnitData = gameState.board[move.row][move.col]; 
                        if(targetUnitData && gameState.units[targetUnitData.id]) {
                            gameState.units[targetUnitData.id].classList.add('pulse-target');
                        }
                    }
                }
            });
            updateInfoDisplay(); 
            updateSelectedUnitInfoPanel();
        }
        
        function updateSelectedUnitInfoPanel() { 
            if (gameState.selectedUnit && gameState.selectedUnit.data) {
                const unit = gameState.selectedUnit.data;
                const unitTypeData = UNIT_TYPES[unit.type];
                unitNameText.textContent = `${unitTypeData.name} (J${unit.player})`;
                unitHealthText.textContent = `${unit.hp}/${unit.maxHp}`;
                unitAttackText.textContent = unitTypeData.attack;
                unitMovementText.textContent = unitTypeData.movement;
            } else {
                unitNameText.textContent = "Ninguna";
                unitHealthText.textContent = "--"; unitAttackText.textContent = "--"; unitMovementText.textContent = "--";
            }
        }

        function onTileClick(row, col) {
            if (!gameState.gameActive || gameState.isAnimating) return;

            if (gameState.gameMode === 'online') {
                if (!gameState.currentFirebaseGameData || gameState.currentFirebaseGameData.currentPlayerId !== gameState.localPlayerId) return;
            } else { 
                if (gameState.gameMode === 'vsAI' && gameState.currentPlayer === gameState.aiPlayerNumber) return;
            }

            const unitDataOnTile = gameState.board[row][col]; 
            const highlightedAction = gameState.highlightedMoves.find(m => m.row === row && m.col === col);

            if (highlightedAction && gameState.selectedUnit) {
                const actingUnitData = gameState.selectedUnit.data; 
                if (gameState.gameMode === 'online') {
                    if (highlightedAction.type === 'move') performMoveOnline(actingUnitData, row, col);
                    else if (highlightedAction.type === 'attack') performAttackOnline(actingUnitData, gameState.board[row][col]);
                } else { 
                    if (highlightedAction.type === 'move') moveUnitAndAnimateLocal(actingUnitData, row, col);
                    else if (highlightedAction.type === 'attack') attackUnitAndAnimateLocal(actingUnitData, gameState.board[row][col]);
                }
            } 
            else if (unitDataOnTile && unitDataOnTile.player === gameState.currentPlayer) {
                selectUnit(unitDataOnTile);
                renderHighlightsAndInfo();
            } 
            else {
                clearHighlightsAndSelection();
                renderHighlightsAndInfo();
            }
        }

        function selectUnit(unitData) { 
            clearHighlightsAndSelection(); 
            gameState.selectedUnit = { data: unitData }; 
            calculatePossibleMovesAndAttacksForUnit(unitData, true); 
        }

        function clearHighlightsAndSelection() {
            gameState.selectedUnit = null;
            gameState.highlightedMoves = [];
        }
        
        function calculatePossibleMovesAndAttacksForUnit(unitData, updateGlobalHighlights = false) {
            const possibleActions = [];
            if (!unitData) return possibleActions; 
            const { movement, range } = UNIT_TYPES[unitData.type];
            const startR = unitData.row; const startC = unitData.col;

            if (movement > 0) {
                let q=[{r:startR,c:startC,dist:0}],v=new Set([`${startR},${startC}`]);
                while(q.length>0){let curr=q.shift();if(curr.dist<movement){const n=[[-1,0],[1,0],[0,-1],[0,1]];for(const [dr,dc] of n){const nr=curr.r+dr,nc=curr.c+dc,pk=`${nr},${nc}`;if(nr>=0&&nr<BOARD_ROWS&&nc>=0&&nc<BOARD_COLS&&!v.has(pk)){const tt=getTileType(nr,nc);if(tt!=='river'&&!gameState.board[nr][nc]){const a={unitId:unitData.id,fromR:startR,fromC:startC,row:nr,col:nc,type:'move'};possibleActions.push(a);if(updateGlobalHighlights)gameState.highlightedMoves.push(a);v.add(pk);q.push({r:nr,c:nc,dist:curr.dist+1});}}}}}
            }
            if (range > 0) {
                for(let ro=-range;ro<=range;ro++){for(let co=-range;co<=range;co++){if(Math.abs(ro)+Math.abs(co)>range||(ro===0&&co===0))continue;const tr=startR+ro,tc=startC+co;if(tr>=0&&tr<BOARD_ROWS&&tc>=0&&tc<BOARD_COLS){const tudob=gameState.board[tr][tc];if(tudob&&tudob.player!==unitData.player){const a={unitId:unitData.id,fromR:startR,fromC:startC,row:tr,col:tc,type:'attack',targetId:tudob.id};possibleActions.push(a);if(updateGlobalHighlights)gameState.highlightedMoves.push(a);}}}}
            }
            return possibleActions;
        }

        function canPlayerMakeAnyMoveLocal(playerNumber) { 
            for (const unitId in gameState.units) {
                const unitElement = gameState.units[unitId];
                const unitData = unitElement.__unitData; 
                if (unitData && unitData.player === playerNumber && unitData.isMobile) { 
                    const possibleActions = calculatePossibleMovesAndAttacksForUnit(unitData, false); 
                    if (possibleActions.length > 0) return true; 
                }
            }
            return false; 
        }

        // --- Local/AI Game Actions ---
        async function moveUnitAndAnimateLocal(unitData, toR, toC) {
            gameState.isAnimating = true;
            clearHighlightsAndSelection(); renderHighlightsAndInfo(); 
            const unitElement = gameState.units[unitData.id];
            const fromR = unitData.row; const fromC = unitData.col;
            addLogEntry(`Unidad ${UNIT_TYPES[unitData.type].name} (J${unitData.player}) se mueve de (${fromR},${fromC}) a (${toR},${toC}).`, 'move');
            playSound('move', 'E4');
            const targetTransform = `translate(${toC * TILE_SIZE}px, ${toR * TILE_SIZE}px)`;
            unitElement.style.transform = targetTransform;
            await new Promise(resolve => unitElement.addEventListener('transitionend', resolve, {once: true}));
            gameState.board[toR][toC] = unitData; gameState.board[fromR][fromC] = null;
            unitData.row = toR; unitData.col = toC;
            gameState.isAnimating = false;
            if (gameState.gameActive) switchTurnLocal(); 
        }
        async function attackUnitAndAnimateLocal(attackerData, targetData) {
            if (!attackerData || !targetData || attackerData.player === targetData.player) { gameState.isAnimating = false; return; }
            gameState.isAnimating = true; clearHighlightsAndSelection(); renderHighlightsAndInfo();
            const attackerElement = gameState.units[attackerData.id]; const targetElement = gameState.units[targetData.id];
            addLogEntry(`Unidad ${UNIT_TYPES[attackerData.type].name} (J${attackerData.player}) ataca a ${UNIT_TYPES[targetData.type].name} (J${targetData.player}).`, 'attack');
            playSound('attack');
            const originalAttackerTransform = `translate(${attackerData.col*TILE_SIZE}px, ${attackerData.row*TILE_SIZE}px)`;
            const lungeDx = (targetData.col-attackerData.col)*TILE_SIZE/4; const lungeDy = (targetData.row-attackerData.row)*TILE_SIZE/4;
            attackerElement.style.transform = `translate(${attackerData.col*TILE_SIZE+lungeDx}px, ${attackerData.row*TILE_SIZE+lungeDy}px)`;
            await new Promise(r=>setTimeout(r,150)); attackerElement.style.transform=originalAttackerTransform; await new Promise(r=>setTimeout(r,150));
            targetData.hp -= attackerData.attack;
            addLogEntry(`${UNIT_TYPES[targetData.type].name} (J${targetData.player}) recibe ${attackerData.attack} daño. PV: ${Math.max(0,targetData.hp)}.`, 'damage');
            playSound('damage', targetData.hp<=0?'A2':'A3');
            targetElement.classList.add('unit-damaged'); updateUnitHPDisplay(targetData); renderUnitRosterLocal();
            await new Promise(r=>targetElement.addEventListener('animationend',r,{once:true})); targetElement.classList.remove('unit-damaged');
            if(targetData.hp<=0){
                addLogEntry(`¡${UNIT_TYPES[targetData.type].name} (J${targetData.player}) destruido!`, 'death'); playSound('death');
                const currentTransform = targetElement.style.transform;
                targetElement.style.transform = `${currentTransform} scale(0.3) rotate(720deg)`; targetElement.style.opacity = '0';
                await new Promise(r=>{const end=e=>{if(e.propertyName==='opacity'||e.propertyName==='transform'){targetElement.removeEventListener('transitionend',end);if(targetElement.parentElement)targetElement.remove();r();}};targetElement.addEventListener('transitionend',end);});
                gameState.board[targetData.row][targetData.col]=null; delete gameState.units[targetData.id]; renderUnitRosterLocal();
                if(targetData.type==='BASE'){endGameLocal(attackerData.player,"Base Destruida"); gameState.isAnimating=false; return;}
            }
            gameState.isAnimating=false; if(gameState.gameActive)switchTurnLocal();
        }
        function switchTurnLocal() {
            clearHighlightsAndSelection(); 
            gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
            addLogEntry(`Turno del Jugador ${gameState.currentPlayer}.`, 'turn');
            playSound('turn', gameState.currentPlayer === 1 ? 'G5' : 'A5');
            if (gameState.gameActive && !canPlayerMakeAnyMoveLocal(gameState.currentPlayer)) { 
                endGameLocal(gameState.currentPlayer === 1 ? 2 : 1, "Sin Movimientos"); return;
            }
            renderHighlightsAndInfo(); renderUnitRosterLocal();
            if (gameState.gameMode === 'vsAI' && gameState.currentPlayer === gameState.aiPlayerNumber && gameState.gameActive) {
                aiTurnIndicator.style.display = 'block';
                setTimeout(aiTakeTurn, 1200); 
            } else {
                aiTurnIndicator.style.display = 'none';
            }
        }
        function endGameLocal(winner, reason = "Condición de Victoria") {
            gameState.gameActive = false; aiTurnIndicator.style.display = 'none';
            const modal = document.getElementById('gameOverModal'); const messageElement = document.getElementById('gameOverMessage');
            messageElement.innerHTML = `¡Jugador ${winner} Gana!<br><span style="font-size:0.8em;color:#a0aec0;">(${reason})</span>`;
            messageElement.className=''; messageElement.classList.add(winner===1?'winner-player1':'winner-player2');
            modal.style.display='flex'; addLogEntry(`¡JUEGO TERMINADO! Jugador ${winner} ha ganado. Razón: ${reason}.`, 'death');
            playSound('death','C4'); clearHighlightsAndSelection(); renderHighlightsAndInfo();
        }
        
        // --- AI Logic ---
        function aiTakeTurn() {
            if (!gameState.gameActive || gameState.currentPlayer !== gameState.aiPlayerNumber) return;
            aiTurnIndicator.textContent = "IA ("+ gameState.aiDifficulty +") pensando...";
            let allPossibleActions = [];
            for (const unitId in gameState.units) {
                const unitElement = gameState.units[unitId]; const unitData = unitElement.__unitData;
                if (unitData && unitData.player === gameState.aiPlayerNumber) {
                    const actions = calculatePossibleMovesAndAttacksForUnit(unitData, false);
                    allPossibleActions.push(...actions);
                }
            }
            if (allPossibleActions.length === 0) { switchTurnLocal(); return; }
            const attackActions = allPossibleActions.filter(a => a.type === 'attack');
            if (attackActions.length > 0) {
                // TODO: Implement difficulty-based attack choice
                const randomAttack = attackActions[Math.floor(Math.random() * attackActions.length)];
                const attackerData = gameState.board[randomAttack.fromR][randomAttack.fromC];
                const targetData = gameState.board[randomAttack.row][randomAttack.col];
                if (attackerData && targetData) attackUnitAndAnimateLocal(attackerData, targetData);
                else aiChooseRandomMoveLocal(allPossibleActions);
            } else { aiChooseRandomMoveLocal(allPossibleActions); }
        }
        function aiChooseRandomMoveLocal(allPossibleActions) {
            const moveActions = allPossibleActions.filter(a => a.type === 'move');
            if (moveActions.length > 0) {
                 // TODO: Implement difficulty-based move choice
                const randomMove = moveActions[Math.floor(Math.random() * moveActions.length)];
                const unitToMove = gameState.board[randomMove.fromR][randomMove.fromC];
                if (unitToMove) moveUnitAndAnimateLocal(unitToMove, randomMove.row, randomMove.col);
                else switchTurnLocal();
            } else { switchTurnLocal(); }
        }

        // --- Firebase Online Game Logic ---
        const FIRESTORE_GAME_PATH_PREFIX = "river_wars_online_games_v2"; 
        
        async function performMoveOnline(unitData, toR, toC) {
            if (!gameState.currentGameId || !firestoreDB) return;
            gameState.isAnimating = true; 
            const gameRef = doc(firestoreDB, `${FIRESTORE_GAME_PATH_PREFIX}/${gameState.currentGameId}`);
            const newLogEntry = {text: `Unidad ${UNIT_TYPES[unitData.type].name} (J${unitData.player}) se mueve de (${unitData.row},${unitData.col}) a (${toR},${toC}).`, type:'move', timestamp:new Date().toISOString()};
            try {
                await runTransaction(firestoreDB, async (transaction) => {
                    const gameDoc = await transaction.get(gameRef); if (!gameDoc.exists()) throw "Game DNE!";
                    const जीडी = gameDoc.data(); const uU = {...GD.units}; const mU = uU[unitData.id];
                    if(!mU || mU.player !== gameState.localPlayerNumber || जीडी.currentPlayerId !== gameState.localPlayerId) throw "Invalid move.";
                    mU.row = toR; mU.col = toC;
                    const nPId = जीडी.player1Id === gameState.localPlayerId ? जीडी.player2Id : जीडी.player1Id;
                    const uL = [newLogEntry, ...GD.gameLog.slice(0,49)];
                    transaction.update(gameRef, {units:uU, currentPlayerId:nPId, lastMoveAt:serverTimestamp(), gameLog:uL});
                });
                playSound('move','E4'); 
            } catch (e) { console.error("Move err:",e); showNotification("Move Error",`${e}`);} 
            finally { gameState.isAnimating=false; clearHighlightsAndSelection(); renderHighlightsAndInfo(); }
        }
        async function performAttackOnline(attackerData, targetData) {
            if (!gameState.currentGameId || !firestoreDB || !targetData) return;
            gameState.isAnimating = true;
            const gameRef = doc(firestoreDB, `${FIRESTORE_GAME_PATH_PREFIX}/${gameState.currentGameId}`);
            let attackerName=UNIT_TYPES[attackerData.type].name; let targetName=UNIT_TYPES[targetData.type].name; let damageDealt=UNIT_TYPES[attackerData.type].attack;
            let logEntries = [];
            logEntries.unshift({text:`Unidad ${attackerName} (J${attackerData.player}) ataca a ${targetName} (J${targetData.player}).`,type:'attack',timestamp:new Date().toISOString()});
            try {
                await runTransaction(firestoreDB, async (transaction) => {
                    const gameDoc = await transaction.get(gameRef); if(!gameDoc.exists()) throw "Game DNE!";
                    const जीडी = gameDoc.data(); const uU = {...GD.units}; const fA = uU[attackerData.id]; const fT = uU[targetData.id];
                    if(!fA || !fT || fA.player !== gameState.localPlayerNumber || जीडी.currentPlayerId !== gameState.localPlayerId) throw "Invalid attack.";
                    fT.hp -= damageDealt;
                    logEntries.unshift({text:`${targetName} (J${fT.player}) recibe ${damageDealt} daño. PV: ${Math.max(0,fT.hp)}.`,type:'damage',timestamp:new Date().toISOString()});
                    let nS=GD.status; let wR=GD.winnerReason||"";
                    if(fT.hp<=0){
                        logEntries.unshift({text:`¡${targetName} (J${fT.player}) destruido!`,type:'death',timestamp:new Date().toISOString()});
                        delete uU[targetData.id];
                        if(fT.type==='BASE'){nS=fA.player===1?'player1_wins':'player2_wins';wR="Base Destruida";}
                    }
                    const nPId = जीडी.player1Id === gameState.localPlayerId ? जीडी.player2Id : जीडी.player1Id;
                    let fNPId = nPId;
                    if(nS==='active' && !canPlayerMakeAnyMoveOnline(nPId, {...GD, units:uU})){
                        nS = fA.player === 1 ? 'player1_wins' : 'player2_wins'; wR = "Oponente sin movimientos";
                        logEntries.unshift({text:`Jugador ${fA.player} gana! Oponente (Jugador ${fT.player}) no tiene movimientos.`,type:'death',timestamp:new Date().toISOString()});
                        fNPId = null;
                    }
                    const uL = [...logEntries, ...GD.gameLog.slice(0, 50 - logEntries.length)];
                    transaction.update(gameRef, {units:uU, currentPlayerId:nS==='active'?fNPId:null, status:nS, winnerReason:wR, lastMoveAt:serverTimestamp(), gameLog:uL});
                });
                playSound('attack');
            } catch(e){console.error("Attack err:",e); showNotification("Attack Error",`${e}`);}
            finally{gameState.isAnimating=false; clearHighlightsAndSelection(); renderHighlightsAndInfo();}
        }
        function canPlayerMakeAnyMoveOnline(playerId, gameData) { 
            const playerNumber = gameData.player1Id === playerId ? 1 : (gameData.player2Id === playerId ? 2 : 0);
            if (!playerNumber) return false;
            const tempBoard = Array(BOARD_ROWS).fill(null).map(() => Array(BOARD_COLS).fill(null));
            for (const uId in gameData.units) { const u = gameData.units[uId]; if(u) tempBoard[u.row][u.col] = u; }

            for (const unitId in gameData.units) {
                const unitData = gameData.units[unitId];
                if (unitData && unitData.player === playerNumber && unitData.isMobile) { 
                    const possibleActions = calculatePossibleMovesAndAttacksForUnit_Firestore(unitData, tempBoard);
                    if (possibleActions.length > 0) return true; 
                }
            }
            return false; 
        }
        function calculatePossibleMovesAndAttacksForUnit_Firestore(unitData, boardState) { 
            const possibleActions = []; const { movement, range } = UNIT_TYPES[unitData.type];
            const startR = unitData.row; const startC = unitData.col;
            if(movement>0){let q=[{r:startR,c:startC,dist:0}],v=new Set([`${startR},${startC}`]);while(q.length>0){let curr=q.shift();if(curr.dist<movement){const n=[[-1,0],[1,0],[0,-1],[0,1]];for(const [dr,dc] of n){const nr=curr.r+dr,nc=curr.c+dc,pk=`${nr},${nc}`;if(nr>=0&&nr<BOARD_ROWS&&nc>=0&&nc<BOARD_COLS&&!v.has(pk)){const tt=getTileType(nr,nc);if(tt!=='river'&&!boardState[nr][nc]){possibleActions.push({type:'move'});return possibleActions;}}}}}}
            if(range>0){for(let ro=-range;ro<=range;ro++){for(let co=-range;co<=range;co++){if(Math.abs(ro)+Math.abs(co)>range||(ro===0&&co===0))continue;const tr=startR+ro,tc=startC+co;if(tr>=0&&tr<BOARD_ROWS&&tc>=0&&tc<BOARD_COLS){const tudob=boardState[tr][tc];if(tudob&&tudob.player!==unitData.player){possibleActions.push({type:'attack'});return possibleActions;}}}}}
            return possibleActions;
        }
        
        function updateInfoDisplay() { 
            let currentPlayerNumberDisplay;
            if (gameState.gameMode === 'online' && gameState.currentFirebaseGameData) {
                const gd = gameState.currentFirebaseGameData;
                currentPlayerNumberDisplay = gd.currentPlayerId === gd.player1Id ? 1 : (gd.currentPlayerId === gd.player2Id ? 2 : 'N/A');
                playerRoleDisplay.textContent = `Eres: ${gameState.localPlayerRole || 'Espectador'} (Jugador ${gameState.localPlayerNumber})`;
                gameIdInfoDisplay.textContent = gameState.currentGameId || "---";
                gameIdInfoDisplay.style.display = 'block';
            } else { 
                currentPlayerNumberDisplay = gameState.currentPlayer;
                playerRoleDisplay.textContent = gameState.gameMode === 'vsAI' ? `Eres: Jugador 1` : `Modo Local`;
                gameIdInfoDisplay.style.display = 'none';
            }
            currentPlayerText.textContent = `Jugador ${currentPlayerNumberDisplay}`;
            currentPlayerText.className = currentPlayerNumberDisplay === 1 ? 'player1' : 'player2';
            gameModeInfoDisplay.textContent = `Modo: ${gameState.gameMode === 'vsAI' ? `VS IA (${gameState.aiDifficulty})` : (gameState.gameMode === 'online' ? 'Online' : 'Local')}`;

            if (gameState.gameMode === 'vsAI' && gameState.currentPlayer === gameState.aiPlayerNumber && gameState.gameActive) {
                aiTurnIndicator.style.display = 'block';
            } else {
                aiTurnIndicator.style.display = 'none';
            }
        }

        function showEndGameModal(winner, reason) { 
            gameState.gameActive = false; aiTurnIndicator.style.display = 'none';
            const modal = document.getElementById('gameOverModal'); const messageElement = document.getElementById('gameOverMessage');
            if (winner) {
                messageElement.innerHTML = `¡Jugador ${winner} Gana!<br><span style="font-size:0.8em;color:#a0aec0;">(${reason})</span>`;
                messageElement.className=''; messageElement.classList.add(winner===1?'winner-player1':'winner-player2');
            } else { messageElement.innerHTML = `¡Empate!<br><span style="font-size:0.8em;color:#a0aec0;">(${reason})</span>`; messageElement.className=''; }
            modal.style.display='flex'; playSound('death','C4'); 
        }
        
        // --- Game Setup and Navigation ---
        function showScreen(screenId) {
            [authLoadingScreen, mainMenuScreen, difficultyScreen, onlineLobbyScreen, waitingRoomScreen, gameContainer, gameOverModal].forEach(el => {
                if(el) el.style.display = 'none';
            });
            const screenToShow = document.getElementById(screenId);
            if (screenToShow) screenToShow.style.display = 'flex'; 
            if (screenId === 'gameContainer') gameContainer.style.display = 'flex'; 
        }

        async function handleFirebaseAuthStateChanged(user) {
            if (user) {
                gameState.localPlayerId = user.uid;
                if(playerUserIdDisplay_Lobby) playerUserIdDisplay_Lobby.textContent = user.uid.substring(0,12) + "...";
                console.log("Autenticado como:", user.uid);
                showScreen('mainMenuScreen');
            } else {
                console.log("No autenticado, intentando iniciar sesión anónimamente...");
                try {
                    if (firebaseAuth) { 
                        await signInAnonymously(firebaseAuth);
                        console.log("Signed in anonymously for deployment. Waiting for auth state change...");
                    } else { 
                        console.error("Firebase Auth no está inicializado al intentar signInAnonymously.");
                        authLoadingScreen.innerHTML = '<h2>Error de Autenticación</h2><p>Firebase Auth no disponible.</p>';
                    }
                } catch (error) { 
                    console.error("Error en inicio de sesión anónimo:", error);
                    authLoadingScreen.innerHTML = `<h2>Error de Autenticación</h2><p>Fallo en inicio de sesión: ${error.message}. Recarga.</p>`;
                    showNotification("Error de Autenticación", `Fallo en inicio de sesión: ${error.message}`);
                }
            }
        }
        
        createGameBtn_Lobby.addEventListener('click', async () => {
            if (!firestoreDB || !gameState.localPlayerId) { showNotification("Error", "Firebase no está listo."); return; }
            const gameId = Math.random().toString(36).substring(2, 8).toUpperCase();
            gameState.currentGameId = gameId;
            gameState.localPlayerRole = 'player1'; gameState.localPlayerNumber = 1;

            const initialUnits = {};
            const p1Base = createUnitData('BASE',1,0); p1Base.row=BOARD_ROWS-1; p1Base.col=Math.floor(BOARD_COLS/2); initialUnits[p1Base.id]=p1Base;
            const p1G1=createUnitData('GUERRERO',1,1); p1G1.row=BOARD_ROWS-2; p1G1.col=Math.floor(BOARD_COLS/2)-1; initialUnits[p1G1.id]=p1G1;
            const p1A1=createUnitData('ARQUERO',1,2); p1A1.row=BOARD_ROWS-2; p1A1.col=Math.floor(BOARD_COLS/2)+1; initialUnits[p1A1.id]=p1A1;
            const p1T1=createUnitData('GIGANTE',1,3); p1T1.row=BOARD_ROWS-3; p1T1.col=Math.floor(BOARD_COLS/2); initialUnits[p1T1.id]=p1T1;
            const p2Base=createUnitData('BASE',2,0); p2Base.row=0; p2Base.col=Math.floor(BOARD_COLS/2); initialUnits[p2Base.id]=p2Base;
            const p2G1=createUnitData('GUERRERO',2,1); p2G1.row=1; p2G1.col=Math.floor(BOARD_COLS/2)-1; initialUnits[p2G1.id]=p2G1;
            const p2A1=createUnitData('ARQUERO',2,2); p2A1.row=1; p2A1.col=Math.floor(BOARD_COLS/2)+1; initialUnits[p2A1.id]=p2A1;
            const p2T1=createUnitData('GIGANTE',2,3); p2T1.row=2; p2T1.col=Math.floor(BOARD_COLS/2); initialUnits[p2T1.id]=p2T1;

            const gameData = {
                gameId: gameId, player1Id: gameState.localPlayerId, player2Id: null,
                currentPlayerId: gameState.localPlayerId, units: initialUnits, status: 'waiting', 
                createdAt: serverTimestamp(), lastMoveAt: serverTimestamp(),
                gameLog: [{text: `Partida ${gameId} creada por Jugador 1 (${gameState.localPlayerId.substring(0,5)}...).`, type: 'system', timestamp: new Date().toISOString()}],
                winnerReason: ""
            };
            try {
                const gameRef = doc(firestoreDB, `${FIRESTORE_GAME_PATH_PREFIX}/${gameId}`);
                await setDoc(gameRef, gameData);
                addLogEntry(`Partida ${gameId} creada. Esperando oponente...`, "system");
                joinGameSessionOnline(gameId);
            } catch (e) { console.error("Err creando partida:",e); showNotification("Error",`No se pudo crear: ${e.message}`);}
        });

        joinGameBtn_Lobby.addEventListener('click', async () => {
            const gameId = joinGameIdInput_Lobby.value.trim().toUpperCase();
            if (!gameId) { showNotification("Error", "Ingresa un ID de partida."); return; }
            if (!firestoreDB || !gameState.localPlayerId) { showNotification("Error", "Firebase no está listo."); return; }
            const gameRef = doc(firestoreDB, `${FIRESTORE_GAME_PATH_PREFIX}/${gameId}`);
            try {
                await runTransaction(firestoreDB, async (transaction) => {
                    const gameDoc = await transaction.get(gameRef); if (!gameDoc.exists()) throw new Error("Partida no encontrada.");
                    const जीडी = gameDoc.data();
                    if (GD.player2Id && जीडी.player2Id !== gameState.localPlayerId) throw new Error("Partida llena.");
                    if (GD.player1Id === gameState.localPlayerId) { gameState.localPlayerRole='player1'; gameState.localPlayerNumber=1; }
                    else if (!GD.player2Id) { 
                        transaction.update(gameRef, { player2Id:gameState.localPlayerId, status:'active', gameLog:[{text:`Jugador 2 (${gameState.localPlayerId.substring(0,5)}...) se unió.`,type:'system',timestamp:new Date().toISOString()}, ...GD.gameLog.slice(0,49)]});
                        gameState.localPlayerRole='player2'; gameState.localPlayerNumber=2;
                    } else if (GD.player2Id === gameState.localPlayerId) { gameState.localPlayerRole='player2'; gameState.localPlayerNumber=2; }
                    else throw new Error("No se pudo unir (estado inesperado).");
                });
                gameState.currentGameId = gameId;
                addLogEntry(`Unido a partida ${gameId} como ${gameState.localPlayerRole}.`, "system");
                joinGameSessionOnline(gameId);
            } catch (e) { console.error("Err uniéndose:",e); showNotification("Error al Unirse",`No se pudo unir: ${e.message}`);}
        });
        
        function joinGameSessionOnline(gameId) {
            showScreen('waitingRoomScreen');
            waitingGameIdDisplay.textContent = gameId;
            waitingStatusText.textContent = "Cargando partida...";
            gameIdInfoDisplay.textContent = gameId;

            if (gameState.unsubscribeGameListener) gameState.unsubscribeGameListener();
            const gameRef = doc(firestoreDB, `${FIRESTORE_GAME_PATH_PREFIX}/${gameId}`);
            gameState.unsubscribeGameListener = onSnapshot(gameRef, (docSnap) => {
                if (docSnap.exists()) {
                    const gameData = docSnap.data();
                    gameState.currentFirebaseGameData = gameData; 

                    if (!gameState.localPlayerRole) { 
                        if (gameData.player1Id === gameState.localPlayerId) { gameState.localPlayerRole = 'player1'; gameState.localPlayerNumber = 1; }
                        else if (gameData.player2Id === gameState.localPlayerId) { gameState.localPlayerRole = 'player2'; gameState.localPlayerNumber = 2; }
                    }
                    
                    playerListDiv.innerHTML = `J1: ${gameData.player1Id ? gameData.player1Id.substring(0,8) : '---'} <br> J2: ${gameData.player2Id ? gameData.player2Id.substring(0,8) : '(Esperando...)'}`;

                    if (gameData.status === 'waiting' && gameData.player2Id === null) {
                        waitingStatusText.textContent = "Esperando al oponente...";
                    } else if (gameData.status === 'active' || gameData.status.includes('_wins') || gameData.status === 'draw') {
                        showScreen('gameContainer');
                        if (!gameBoardElement.hasChildNodes() || Object.keys(gameState.units).length === 0) { 
                            initializeBoardAndUnitsFirebase(); 
                        }
                        updateBoardFromFirestore(gameData); 
                        if (gameData.status === 'active' && !gameState.gameActive) playSound('turn'); 
                        gameState.gameActive = gameData.status === 'active';
                    }
                } else {
                    showNotification("Error de Partida", "La partida ya no existe o fue eliminada.");
                    leaveGameCleanup();
                }
            }, (error) => {
                console.error("Error en snapshot:", error);
                showNotification("Error de Conexión", "Se perdió la conexión.");
                leaveGameCleanup();
            });
        }
        
        function initializeBoardAndUnitsFirebase() {
            gameState.riverCanvases = []; 
            unitLayerElement.innerHTML = ''; 
            unitLayerElement.style.width = `${BOARD_COLS * TILE_SIZE}px`; 
            unitLayerElement.style.height = `${BOARD_ROWS * TILE_SIZE}px`;
            gameBoardElement.innerHTML = ''; 
            gameBoardElement.style.gridTemplateColumns = `repeat(${BOARD_COLS}, ${TILE_SIZE}px)`;
            gameBoardElement.style.gridTemplateRows = `repeat(${BOARD_ROWS}, ${TILE_SIZE}px)`;
            for (let r = 0; r < BOARD_ROWS; r++) {
                for (let c = 0; c < BOARD_COLS; c++) {
                    const tile = document.createElement('div');
                    const tileType = getTileType(r, c);
                    tile.classList.add('tile', tileType);
                    tile.dataset.row = r; tile.dataset.col = c;
                    if (tileType === 'river') {
                        const canvas = document.createElement('canvas');
                        canvas.width = TILE_SIZE; canvas.height = TILE_SIZE;
                        canvas.classList.add('river-canvas');
                        tile.appendChild(canvas);
                        gameState.riverCanvases.push(canvas.getContext('2d'));
                    }
                    tile.addEventListener('click', () => onTileClick(r, c));
                    gameBoardElement.appendChild(tile);
                }
            }
            addLogEntry("Tablero inicializado para partida online.", "system");
        }

        function updateBoardFromFirestore(firebaseGameData) {
            gameState.currentFirebaseGameData = firebaseGameData;
            gameState.gameActive = firebaseGameData.status === 'active';
            
            const newClientUnits = {}; // To track units currently on client
            const newBoardModel = Array(BOARD_ROWS).fill(null).map(() => Array(BOARD_COLS).fill(null));

            if (firebaseGameData.units) {
                for (const unitId in firebaseGameData.units) {
                    const unitDataFS = firebaseGameData.units[unitId];
                    if (unitDataFS && unitDataFS.row !== undefined && unitDataFS.col !== undefined) {
                        newBoardModel[unitDataFS.row][unitDataFS.col] = unitDataFS; 
                        let unitElement = gameState.units[unitId]; // Try to find existing element
                        if (!unitElement) { // If not exists, create it
                            unitElement = createUnitElement(unitDataFS);
                        } else { // If exists, update its position and internal data
                            unitElement.__unitData = unitDataFS; // Keep internal data fresh
                            unitElement.style.transform = `translate(${unitDataFS.col * TILE_SIZE}px, ${unitDataFS.row * TILE_SIZE}px)`;
                            // Optionally re-draw canvas if appearance could change based on HP (not implemented yet)
                            const canvas = unitElement.querySelector('canvas');
                            const ctx = canvas.getContext('2d');
                            const drawFunction = unitDrawFunctions[unitDataFS.drawFuncKey];
                            if (drawFunction) drawFunction(ctx, UNIT_CANVAS_SIZE, unitDataFS.player === 1);
                        }
                        newClientUnits[unitId] = unitElement; // Add to new set of client units
                    }
                }
            }
            // Remove unit elements that are no longer in Firestore data
            for (const unitId in gameState.units) {
                if (!newClientUnits[unitId]) {
                    gameState.units[unitId].remove();
                }
            }
            gameState.units = newClientUnits; // Update client unit cache
            gameState.board = newBoardModel; // Update local board model

            if (firebaseGameData.gameLog && !arraysEqual(gameState.gameLog.map(l=>l.text), firebaseGameData.gameLog.map(l=>l.text))) {
                gameState.gameLog = [...firebaseGameData.gameLog]; 
                renderGameLog(); // This is appropriate here as it's syncing the whole log
            }
            renderHighlightsAndInfo(); 
            renderUnitRosterOnline(); // Use specific roster for online

            if (!gameState.gameActive && (firebaseGameData.status.includes('_wins') || firebaseGameData.status === 'draw')) {
                let winner = null; let reason = "Partida Terminada";
                if (firebaseGameData.status === 'player1_wins') winner = 1;
                if (firebaseGameData.status === 'player2_wins') winner = 2;
                if (firebaseGameData.status === 'draw') reason = "Empate";
                else if (firebaseGameData.winnerReason) reason = firebaseGameData.winnerReason;
                
                if (winner || firebaseGameData.status === 'draw') {
                    showEndGameModal(winner, reason);
                }
            }
        }
         function renderUnitRosterOnline() {
            unitRosterPanel.innerHTML = ''; 
            const title = document.createElement('p');
            title.classList.add('roster-title');
            
            let playerNumberForRoster = gameState.localPlayerNumber; // Default to local player
            if (gameState.currentFirebaseGameData && gameState.currentFirebaseGameData.currentPlayerId) {
                 playerNumberForRoster = gameState.currentFirebaseGameData.currentPlayerId === gameState.currentFirebaseGameData.player1Id ? 1 : 2;
            }
            title.textContent = `Unidades del Jugador ${playerNumberForRoster}`;
            unitRosterPanel.appendChild(title);

            let unitsFound = false;
            const unitsToDisplay = gameState.currentFirebaseGameData ? gameState.currentFirebaseGameData.units : {};

            for (const unitId in unitsToDisplay) {
                const unitData = unitsToDisplay[unitId];
                if (unitData && unitData.player === playerNumberForRoster) { 
                    unitsFound = true;
                    const p = document.createElement('p');
                    p.textContent = `${UNIT_TYPES[unitData.type].name}: ${unitData.hp}/${unitData.maxHp} PV`;
                    p.classList.add(unitData.player === 1 ? 'unit-entry-p1' : 'unit-entry-p2');
                    unitRosterPanel.appendChild(p);
                }
            }
            if (!unitsFound) {
                 const p = document.createElement('p');
                 p.textContent = "Ninguna unidad activa.";
                 p.classList.add("text-gray-500", "text-center");
                 unitRosterPanel.appendChild(p);
            }
             unitRosterPanel.scrollTop = 0;
        }


        function arraysEqual(a, b) { 
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
            return true;
        }

        function leaveGameCleanup() { 
            if (gameState.unsubscribeGameListener) { gameState.unsubscribeGameListener(); gameState.unsubscribeGameListener = null; }
            
            if (gameState.gameMode === 'online' && gameState.localPlayerRole === 'player1' && 
                gameState.currentFirebaseGameData && gameState.currentFirebaseGameData.status === 'waiting' && firestoreDB && gameState.currentGameId) {
                deleteDoc(doc(firestoreDB, `${FIRESTORE_GAME_PATH_PREFIX}/${gameState.currentGameId}`))
                    .then(() => addLogEntry(`Partida ${gameState.currentGameId} eliminada por anfitrión.`, "system"))
                    .catch(e => console.error("Error borrando partida al salir:", e));
            }

            gameState.currentGameId = null; gameState.localPlayerRole = null; gameState.localPlayerNumber = null;
            gameState.currentFirebaseGameData = null; gameState.gameActive = false;
            gameState.gameMode = null; gameState.aiDifficulty = null;
            unitLayerElement.innerHTML = ''; gameState.units = {}; gameState.board = [];
            showScreen('mainMenuScreen');
            addLogEntry("Has salido de la partida.", "system");
        }

        leaveWaitingRoomBtn.addEventListener('click', leaveGameCleanup);
        generalLeaveGameBtn.addEventListener('click', leaveGameCleanup);
        modalLeaveGameBtn.addEventListener('click', leaveGameCleanup);

        // Menu Navigation
        localMultiplayerBtn.addEventListener('click', () => startGame('local'));
        vsAIBtn.addEventListener('click', () => showScreen('difficultyScreen'));
        onlineMultiplayerBtn.addEventListener('click', () => {
            if (gameState.localPlayerId && playerUserIdDisplay_Lobby) { 
                 playerUserIdDisplay_Lobby.textContent = gameState.localPlayerId.substring(0,12) + "...";
            }
            showScreen('onlineLobbyScreen');
        });
        backToMainMenuBtn_Diff.addEventListener('click', () => showScreen('mainMenuScreen'));
        backToMainMenuBtn_Lobby.addEventListener('click', () => showScreen('mainMenuScreen'));

        [aiEasyBtn, aiMediumBtn, aiHardBtn].forEach(btn => {
            btn.addEventListener('click', (e) => startGame('vsAI', e.target.dataset.difficulty));
        });
        
        function startGame(mode, difficulty = null) {
            showScreen('gameContainer');
            gameState.gameMode = mode;
            gameState.aiDifficulty = difficulty; 
            
            gameModeInfoDisplay.textContent = `Modo: ${mode === 'vsAI' ? `VS IA (${difficulty})` : (mode === 'online' ? 'Online' : 'Local')}`;

            if (mode === 'local' || mode === 'vsAI') {
                initializeLocalBoardAndUnits(); // Calls addLogEntry which calls renderGameLog
                renderHighlightsAndInfo();
                // renderGameLog(); // Already called
                renderUnitRosterLocal();
            } else if (mode === 'online') {
                // Online game start is handled by create/join logic (which calls joinGameSessionOnline)
                // initializeBoardAndUnitsFirebase() will be called within joinGameSessionOnline's snapshot listener
                // when the game becomes active or data is first loaded.
                // For now, just ensure the game container is visible.
                // The actual board setup will wait for Firestore data.
                addLogEntry("Entrando a modo online...", "system"); // Calls renderGameLog
            }
        }
        
        document.addEventListener('DOMContentLoaded', async () => {
            const firebaseReady = await initializeFirebase(); // Wait for Firebase to be ready
            if (firebaseReady && firebaseAuth) {
                initializeSounds();
                onAuthStateChanged(firebaseAuth, handleFirebaseAuthStateChanged); 
                animateRiver(); 
            } else {
                authLoadingScreen.innerHTML = '<h2>Error Fatal</h2><p>Firebase no pudo inicializarse. El juego no puede continuar.</p>';
            }
        });

    </script>
</body>
</html>
